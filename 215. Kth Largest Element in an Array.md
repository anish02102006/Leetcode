Chalo ğŸ˜„
**LeetCode 215 â€“ Kth Largest Element in an Array** ko **interview-ready depth** me samajhte hain
ğŸ‘‰ **Brute â†’ Better â†’ Optimal**
ğŸ‘‰ **Hinglish explanation + Java code + intuition + complexity**

---

## ğŸ§  Problem Samajh Lo

Tumhe ek integer array diya hai aur ek number `k`.

ğŸ‘‰ Tumhe **k-th largest element** find karna hai
âŒ **Sorting ke baad k-th index nahi**, balki **value**

---

### Example 1:

```
nums = [3,2,1,5,6,4]
k = 2
```

Sorted descending:

```
[6,5,4,3,2,1]
```

ğŸ‘‰ **2nd largest = 5**

---

## âš ï¸ Important Clarification

* Duplicate allowed
* Order matter nahi karta
* **Largest means descending order**

---

# ğŸŸ¥ Brute Force Approach (Sorting)

## ğŸ’¡ Idea:

* Array ko sort karo
* End se `k-1` index uthao

---

### Steps:

1. `Arrays.sort(nums)`
2. Answer = `nums[n - k]`

---

### âŒ Java Code (Brute)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }
}
```

### â± Complexity:

* **Time:** O(N log N)
* **Space:** O(1) / O(log N) (sorting internal)

âš ï¸ Interview me bol sakte ho:

> â€œThis works but we can do better without full sorting.â€

---

# ğŸŸ¡ Better Approach (Min Heap of Size K)

ğŸ”¥ **Most common interview approach**

---

## ğŸ’¡ Idea:

* K largest elements ka **min-heap** banao
* Heap ka top hamesha **k-th largest** hoga

---

### ğŸ§  Logic:

1. MinHeap banate jao
2. Agar size > k â†’ smallest hata do
3. End me heap ka top = answer

---

### ğŸ§ª Example:

```
nums = [3,2,1,5,6,4], k=2

Heap process:
[3]
[2,3]
[3,1] â†’ remove 1
[3,5] â†’ remove 3
[5,6]
[5,6] â†’ remove 4

Answer = 5
```

---

### âœ… Java Code (Heap)

```java
import java.util.PriorityQueue;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int num : nums) {
            minHeap.add(num);
            if (minHeap.size() > k) {
                minHeap.poll(); // smallest remove
            }
        }
        return minHeap.peek();
    }
}
```

---

### â± Complexity:

* **Time:** O(N log K)
* **Space:** O(K)

âœ… Much better than sorting
âœ… Interview-friendly

---

# ğŸŸ¢ Optimal Approach (QuickSelect â€“ Partition Logic)

ğŸ”¥ **Advanced / FAANG favorite**

---

## ğŸ’¡ Core Idea:

* QuickSort jaisa partition
* Par sirf **ek side** me jaate hain
* Average me **O(N)**

---

## ğŸ¯ Trick:

Kth **largest** = `(n - k)` index in sorted array

---

### ğŸ§  Steps:

1. Pivot lo
2. Partition karo
3. Agar pivot index == target â†’ done
4. Nahi to left ya right me jao

---

### âœ… Java Code (QuickSelect)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int target = nums.length - k;
        return quickSelect(nums, 0, nums.length - 1, target);
    }

    private int quickSelect(int[] nums, int left, int right, int k) {
        int pivot = partition(nums, left, right);

        if (pivot == k)
            return nums[pivot];
        else if (pivot < k)
            return quickSelect(nums, pivot + 1, right, k);
        else
            return quickSelect(nums, left, pivot - 1, k);
    }

    private int partition(int[] nums, int left, int right) {
        int pivot = nums[right];
        int i = left;

        for (int j = left; j < right; j++) {
            if (nums[j] <= pivot) {
                swap(nums, i, j);
                i++;
            }
        }
        swap(nums, i, right);
        return i;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

---

### â± Complexity:

* **Average:** O(N)
* **Worst:** O(NÂ²) (rare)
* **Space:** O(1)

---

# ğŸ“Š Comparison Table

| Approach    | Time       | Space | Use Case    |
| ----------- | ---------- | ----- | ----------- |
| Sorting     | O(N log N) | O(1)  | Easy        |
| Min Heap    | O(N log K) | O(K)  | â­ Interview |
| QuickSelect | O(N) avg   | O(1)  | ğŸ”¥ Advanced |

---

## ğŸ¤ Interview Script (One-Liner)

> â€œWe can solve it using sorting, but a better approach is MinHeap of size K.
> For optimal performance, we can use QuickSelect which works in average O(N).â€

---

Agar chaho:

* ğŸ” **Dry run step-by-step**
* ğŸ§ª **Edge cases**
* â“ **Why QuickSelect works**
* ğŸ§  **Which approach when?**

Bas bol do ğŸ˜„
