Introduction & Problem Statement
Welcome to this detailed guide, where we delve into the fascinating problem of reversing a sublist within a singly-linked list. The challenge is not just to reverse a sublist but to do it efficiently, ideally in a single pass through the list. This guide is designed to arm you with multiple approaches for tackling this problem, each with its own unique advantages and considerations. Specifically, we will explore three distinct strategies: Two Pointers, Using a Stack, and Recursion.

Key Concepts and Constraints
Node Anatomy:
Let's start with the basics. In a singly-linked list, each node has an integer value and a next pointer that points to the subsequent node in the list.

Sublist Reversal:
The primary task is to reverse only the nodes between positions left and right, both inclusive, within the list.

Order Preservation:
While reversing the sublist, we must ensure that the relative order of all nodes outside this range remains unchanged.

Size Constraints:
The number of nodes in the list n can vary but will always be between 1 and 500, giving us more than enough to work with.

Live Coding & More


üêç Two Pointers üëâüëà
üêç Stack üìö
üêç Recursion üîÅ
Strategies to Tackle the Problem: A Three-Pronged Approach
1. Using Two Pointers (One-Pass)
Intuition and Logic Behind the Solution
In this efficient method, we employ two pointers to traverse and manipulate the linked list in one go. The clever use of a dummy node helps us elegantly handle edge cases, and tuple unpacking makes the code more Pythonic and straightforward.

Step-by-step Explanation
Initialization:

Create a dummy node and connect its next to the head of the list.
Initialize a prev pointer to the dummy node.
Move to Start Position:

Traverse the list until the node just before the left-th node is reached.
Execute Sublist Reversal:

Use a current pointer to keep track of the first node in the sublist.
Reverse the sublist nodes using prev and current.
Link Back:

Automatically link the reversed sublist back into the original list.
Complexity Analysis
Time Complexity: O(n) ‚Äî A single traversal does the job.
Space Complexity: O(1) ‚Äî Smart pointer manipulation eliminates the need for additional data structures.
2. Using a Stack
Intuition and Logic Behind the Solution
This approach uses a stack data structure to temporarily store and then reverse the sublist, making the logic easier to follow.

Step-by-step Explanation
Initialization:

Like before, create a dummy node and set a prev pointer.
Populate the Stack:

Traverse the list and populate the stack with the nodes falling within the left and right positions.
Perform Reversal and Relink Nodes:

Pop nodes from the stack and relink them, essentially reversing the sublist.
Complexity Analysis
Time Complexity: O(n)
Space Complexity: O(n) ‚Äî The stack takes extra space.
3. Using Recursion
Intuition and Logic Behind the Solution
In this elegant method, the language's call stack is leveraged to reverse the sublist through recursive function calls.

Step-by-step Explanation
Define Recursive Function:

Create a helper function that will do the heavy lifting, taking the node and its position as parameters.
Base and Recursive Cases:

Implement base and recursive cases to control the flow and reversal.
Unwind and Relink:

As the recursion unwinds, the nodes get relinked in the reversed order.
Complexity Analysis
Time Complexity: O(n)
Space Complexity: O(n) ‚Äî The call stack consumes extra memory.
Code Highlights and Best Practices
The use of a dummy node is universal across all methods for handling edge cases gracefully.
Tuple unpacking in the Two-Pointer approach makes the code clean and Pythonic.
The Stack approach makes clever use of the stack data structure for sublist reversal.
The Recursion method leverages the language's call stack for a clean and elegant solution.
Performance
Language	Fastest Runtime (ms)	Memory Usage (MB)	Method
Rust	0	2.3	Two-Pointers
PHP	0	18.9	Two-Pointers
Java	0	40.8	Two-Pointers
Go	1	2.1	Two-Pointers
C++	4	7.4	Two-Pointers
Python3	33	16.6	Two-Pointers
Python3	38	16.6	Recursion
Python3	39	16.3	Stack
JavaScript	44	41.8	Two-Pointers
C#	71	38.4	Two-Pointers

class Solution {


    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || left == right) return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        for (int i = 0; i < left - 1; ++i) {
            prev = prev.next;
        }
        
        ListNode current = prev.next;
        
        for (int i = 0; i < right - left; ++i) {
            ListNode nextNode = current.next;
            current.next = nextNode.next;
            nextNode.next = prev.next;
            prev.next = nextNode;
        }
        
        return dummy.next;
    }
}
