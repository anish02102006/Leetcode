# Intuition
Since each row is sorted and the first element of every row is greater than the last element of the previous row, the entire matrix behaves like one sorted array.
So instead of searching row by row, we can perform a binary search across the whole matrix.

# Approach
Treat the matrix as a flattened sorted 1D array.

Calculate mid using binary search.

Convert mid index back to matrix position using:

row = mid / n
col = mid % n
Compare the value:
If equal → return true

If smaller → search right half

If larger → search left half

# Complexity
Time complexity:O(log(m∗n))
Space complexity:O(1)

# Code
class Solution {


    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        
        int left = 0, right = m * n - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            int row = mid / n;
            int col = mid % n;
            
            if (matrix[row][col] == target) return true;
            else if (matrix[row][col] < target) left = mid + 1;
            else right = mid - 1;
        }
        return false;
    }
}
