# Intuition:
We are asked to count the number of triplets (i, j, k) such that nums[i] = 2 * nums[j] = nums[k].
The idea is to use frequency counts: track how many times a number appears to the left and right
of the current element. For each element nums[j], the number of valid triplets is the product of
the count of 2*nums[j] to its left and to its right.

# Approach:
Initialize two frequency arrays, lCount and rCount, to track counts of numbers to the left and right.
Populate rCount with the frequency of each number in nums.
Iterate through nums:
Decrease rCount[nums[j]] since we are "at" this element.
Calculate target = 2 * nums[j].
If target is within bounds, add lCount[target] * rCount[target] to the result (modulo 1e9+7).
Increment lCount[nums[j]] since it is now part of the left side.
Return the result.
# Complexity:
Time: O(n)
Space: O(maxValue)
where maxValue is the largest number in nums (here using 200000 to safely handle nums[i]*2)

# Code
class Solution {


    public int specialTriplets(int[] nums) {
         int MOD = 1000000007;
        int lCount[]=new int[200000];
        int rCount[]=new int[200000];
        for(int i:nums){
            rCount[i]++;
        }

        long res=0L;
        for(int i=0;i<nums.length;i++){
            rCount[nums[i]]--;
            int target=nums[i]*2;
            if(target<200000){
                long add=((long)rCount[target]*lCount[target])%MOD;
                res=(res+add)%MOD;
            }
            lCount[nums[i]]++;
        }
        return (int)res;

    }
}
