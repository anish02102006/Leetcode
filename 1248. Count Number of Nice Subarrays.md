Alright bhai ğŸ˜„
**LeetCode 1248 â€“ Count Number of Nice Subarrays (Medium)**
isko bhi **Brute â†’ Better â†’ Optimal** style me **Java + Hinglish** me complete tod dete hain ğŸ’¥

---

## ğŸ”´ Problem Samajh Lo

Tumhe ek array diya hai **nums**
aur ek number **k**

ğŸ‘‰ **Nice Subarray** = aisa subarray jisme **exactly k odd numbers** ho.

---

### Example

```
nums = [1,1,2,1,1]
k = 3
```

Odd numbers positions:

```
[1,1,2,1,1]
 O O   O O
```

Valid subarrays:

```
[1,1,2,1]
[1,2,1,1]
```

ğŸ‘‰ Answer = **2**

---

# ğŸŸ  Approach 1: Brute Force (O(nÂ²))

### ğŸ§  Idea

* Har subarray check karo
* Count odd numbers
* Agar oddCount == k â†’ answer++

---

### âŒ Issue

* Large input me TLE ğŸ’€

---

### âœ… Java Code (Brute)

```java
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        int n = nums.length;
        int count = 0;

        for (int i = 0; i < n; i++) {
            int odd = 0;
            for (int j = i; j < n; j++) {
                if (nums[j] % 2 != 0) odd++;
                if (odd == k) count++;
            }
        }
        return count;
    }
}
```

### â± Time: `O(nÂ²)`

### ğŸ“¦ Space: `O(1)`

---

# ğŸŸ¡ Approach 2: Prefix Sum + HashMap (O(n))

### ğŸ”¥ Observation

* Sirf odd numbers matter karte hain
* Har number ko convert kar do:

```
odd â†’ 1
even â†’ 0
```

Ab problem ban jaati hai:

> **Subarrays with sum = k**

Exactly **LeetCode 930** jaisa ğŸ”

---

### âœ… Java Code (Better)

```java
import java.util.*;

class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);

        int prefixSum = 0;
        int count = 0;

        for (int num : nums) {
            if (num % 2 != 0) prefixSum += 1;

            if (map.containsKey(prefixSum - k)) {
                count += map.get(prefixSum - k);
            }

            map.put(prefixSum, map.getOrDefault(prefixSum, 0) + 1);
        }
        return count;
    }
}
```

### â± Time: `O(n)`

### ğŸ“¦ Space: `O(n)`

---

# ğŸŸ¢ Approach 3: Optimal (Sliding Window / Two Pointer Trick)

âš ï¸ Normal sliding window **direct kaam nahi karta**

### ğŸ”¥ Trick

```
Exactly k odds
= At most k odds
- At most (k - 1) odds
```

---

## Helper Function: At Most k Odds

* Right badhao
* Agar oddCount > k â†’ left badhao
* Har step pe `(right - left + 1)` add karo

---

### âœ… Java Code (Optimal)

```java
class Solution {

    private int atMost(int[] nums, int k) {
        int left = 0, count = 0, odd = 0;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] % 2 != 0) odd++;

            while (odd > k) {
                if (nums[left] % 2 != 0) odd--;
                left++;
            }

            count += (right - left + 1);
        }
        return count;
    }

    public int numberOfSubarrays(int[] nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }
}
```

---

### â± Time: `O(n)`

### ğŸ“¦ Space: `O(1)`

ğŸ”¥ **Most Optimal & Interview Favorite**

---

## ğŸ§  Summary Table

| Approach             | Time  | Space | Use     |
| -------------------- | ----- | ----- | ------- |
| Brute                | O(nÂ²) | O(1)  | âŒ       |
| Prefix + Map         | O(n)  | O(n)  | âœ…       |
| Sliding Window Trick | O(n)  | O(1)  | ğŸ”¥ BEST |

---

## ğŸ¯ Interview Connection

Agar interviewer bole:

> â€œNice subarray with k oddsâ€

Tum bolo:

> â€œSir, isko binary conversion + `atMost(k) - atMost(k-1)` se O(n) me solve kar sakte hain.â€

---

Agar chaaho to mai:

* **Dry run step-by-step**
* **Comparison with LC 930**
* **Practice problems list**
* **Common sliding window traps**

sab karwa dunga ğŸ’ª
Bas bol bhai ğŸ”¥
