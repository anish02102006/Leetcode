Intuition
We need to find the length of the list. After that, traverse the list with a pointer and set the length-k node as the new head. Finally, link the last node to the previous first node.

Approach
Initial Checks:

if (head == null || head.next == null || k == 0) {
    return head;
}
If the list is empty (head == null), has only one node (head.next == null), or if k is zero, the list remains unchanged, and the method returns the head as is.
Calculate Length:

int length = 1;
ListNode temp = head;

while (temp.next != null) {
    temp = temp.next;
    length++;
}
A pointer temp is used to traverse the list to calculate its length.
The variable length is initialized to 1 because the loop counts nodes starting from the second node (as the first node is already considered).
The loop continues until temp.next is null, incrementing length with each iteration.
Make the List Circular:

temp.next = head;
After the loop, temp points to the last node in the list.
The next pointer of the last node (temp.next) is set to the head, making the list circular.
Calculate Effective Rotations:

k = k % length;
k = length - k;
The number of rotations k is taken modulo length to handle cases where k is larger than the list length.
The value of k is then adjusted to determine the new head's position by subtracting k from length.
Find New Head:

while (k-- > 0) {
    temp = temp.next;
}
A loop is used to move temp k nodes ahead in the circular list. After the loop, temp will point to the node just before the new head.
Break the Circular List:

head = temp.next;
temp.next = null;
The new head is temp.next.
The circular link is broken by setting temp.next to null.
Return New Head:

return head;
Time and Space Complexity
Time Complexity: O(n), where n is the length of the linked list. This is because we traverse the list once to calculate its length and once again to find the new head.
Space Complexity: O(1), as we are using a constant amount of extra space (no additional data structures are used).

class Solution {


    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k == 0) {
            return head;
        }

        int length = 1;
        ListNode temp = head;

        while (temp.next != null) {
            temp = temp.next;
            length++;
        }

        temp.next = head;
        k = k % length;
        k = length - k;

        while (k-- > 0) {
            temp = temp.next;
        }

        head = temp.next;
        temp.next = null;

        return head;
    }
}
