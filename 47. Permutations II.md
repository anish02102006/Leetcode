Chalo bhai ğŸ˜„
**LeetCode 47 â€“ Permutations II** (with **duplicates**) ko **Brute â†’ Better â†’ Optimal** style me **Java + Hinglish** me todte hain ğŸ”¥

---

## ğŸ”´ Problem Samajh Lo

Tumhe ek array diya hai **nums**, jisme **duplicate elements ho sakte hain**.
Tumhe **saari UNIQUE permutations** return karni hain.

### Example

```
nums = [1,1,2]
```

Valid unique permutations:

```
[1,1,2]
[1,2,1]
[2,1,1]
```

ğŸ‘‰ Duplicate permutations **allowed nahi** âŒ

---

# ğŸŸ  Approach 1: Brute Force (Generate All + Set) âŒ

### ğŸ§  Idea

* Saari permutations banao (n!)
* `Set<List<Integer>>` me daal do
* Duplicates apne aap hat jaayenge

### âŒ Problem

* Extra memory
* Inefficient
* Interview me weak answer

---

### âœ… Java Code (Brute â€“ Not Recommended)

```java
import java.util.*;

class Solution {
    Set<List<Integer>> set = new HashSet<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        backtrack(nums, 0);
        return new ArrayList<>(set);
    }

    private void backtrack(int[] nums, int idx) {
        if (idx == nums.length) {
            List<Integer> list = new ArrayList<>();
            for (int n : nums) list.add(n);
            set.add(list);
            return;
        }

        for (int i = idx; i < nums.length; i++) {
            swap(nums, idx, i);
            backtrack(nums, idx + 1);
            swap(nums, idx, i);
        }
    }

    private void swap(int[] a, int i, int j) {
        int t = a[i]; a[i] = a[j]; a[j] = t;
    }
}
```

â± **Time:** `O(n! * n)`
ğŸ“¦ **Space:** High âŒ

---

# ğŸŸ¡ Approach 2: Sorting + Used Array (Most Common)

### ğŸ”¥ Idea

1. Array **sort** kar do
2. `used[]` boolean array rakho
3. Duplicate ko skip karo using rule ğŸ‘‡

### ğŸ§  Duplicate Skip Rule

```
if (i > 0 && nums[i] == nums[i-1] && !used[i-1])
    continue;
```

ğŸ‘‰ Matlab:
**Same number tabhi lo jab pichla already used ho**

---

### âœ… Java Code (Better)

```java
import java.util.*;

class Solution {
    List<List<Integer>> res = new ArrayList<>();
    boolean[] used;

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backtrack(nums, new ArrayList<>());
        return res;
    }

    private void backtrack(int[] nums, List<Integer> temp) {
        if (temp.size() == nums.length) {
            res.add(new ArrayList<>(temp));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;

            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
                continue;

            used[i] = true;
            temp.add(nums[i]);

            backtrack(nums, temp);

            temp.remove(temp.size() - 1);
            used[i] = false;
        }
    }
}
```

â± **Time:** `O(n!)`
ğŸ“¦ **Space:** `O(n)`

âœ… **Interview Acceptable**

---

# ğŸŸ¢ Approach 3: Optimal (Frequency Map / Count Map) ğŸ”¥ğŸ”¥

### ğŸ§  Best Idea

* Har number ki **frequency count** rakho
* Jab tak count > 0 â†’ use karo
* Duplicate ka question hi nahi aata ğŸ˜

---

### Example

```
nums = [1,1,2]
freq = {1:2, 2:1}
```

---

### âœ… Java Code (Most Clean & Optimal)

```java
import java.util.*;

class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int n : nums)
            freq.put(n, freq.getOrDefault(n, 0) + 1);

        backtrack(new ArrayList<>(), freq, nums.length);
        return res;
    }

    private void backtrack(List<Integer> temp,
                           Map<Integer, Integer> freq,
                           int n) {
        if (temp.size() == n) {
            res.add(new ArrayList<>(temp));
            return;
        }

        for (int key : freq.keySet()) {
            if (freq.get(key) > 0) {
                temp.add(key);
                freq.put(key, freq.get(key) - 1);

                backtrack(temp, freq, n);

                temp.remove(temp.size() - 1);
                freq.put(key, freq.get(key) + 1);
            }
        }
    }
}
```

---

### â± Time: `O(n!)`

### ğŸ“¦ Space: `O(n)`

ğŸ”¥ **Best Conceptually + Clean Code**

---

## ğŸ§  Comparison Table

| Approach      | Duplicate Handling | Interview |
| ------------- | ------------------ | --------- |
| Brute + Set   | âŒ After generation | âŒ         |
| Sort + Used   | âœ… Skip logic       | âœ…         |
| Frequency Map | âœ… Naturally        | ğŸ”¥ BEST   |

---

## ğŸ¯ Interview One-Liner

> â€œSir, duplicates handle karne ke liye frequency map based backtracking best hota hai.â€

---

## ğŸ§© Related Questions

* 46. Permutations
* 39 / 40. Combination Sum
* 78 / 90. Subsets
* 77. Combinations

---

Agar chaaho to mai:

* **Dry run**
* **Recursion tree**
* **Time complexity proof**
* **Permutation vs Combination difference**

sab kara dunga ğŸ˜
Bas bolo bhai ğŸ‘Š
