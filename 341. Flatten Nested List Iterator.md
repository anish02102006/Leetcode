ğŸ”¥ **LeetCode 341 â€“ Flatten Nested List Iterator**
Ye question **DESIGN + STACK + ITERATOR** ka classic example hai.
Interviewers ko pasand hai kyunki yeh **lazy vs eager flattening** samjhata hai.

Main explain karunga **teacher-style, Hinglish**, bilkul board-friendly ğŸ‘‡

---

# ğŸ§  Problem Samajh Lo

Tumhe ek **NestedInteger** list di gayi hai:

```
[1,[4,[6]]]
```

Tumhe ek iterator banana hai jo output de:

```
1 4 6
```

---

# ğŸ“¦ Given Interface (Important)

```java
public interface NestedInteger {
    boolean isInteger();
    Integer getInteger();
    List<NestedInteger> getList();
}
```

Tum **NestedInteger class implement nahi karte**, sirf use karte ho.

---

# ğŸ§© Two Possible Approaches

| Approach | Idea                           |
| -------- | ------------------------------ |
| Eager    | Pehle pura flatten karo        |
| Lazy     | Jab next() bole tab hi flatten |

ğŸ‘‰ **Lazy approach preferred** (optimal & elegant)

---

# ğŸŸ¢ Optimal Approach: **Stack (Lazy Flattening)** ğŸ”¥

## ğŸ’¡ Core Intuition

* Stack me **NestedInteger objects** rakho
* Hamesha stack ke top ko check karo:

  * Agar integer â†’ return it
  * Agar list â†’ usko unfold (reverse order me push)

---

# ğŸªœ Algorithm Steps

### Constructor:

* Stack me initial list ko **reverse order** me push karo

### hasNext():

* Jab tak stack empty nahi:

  * Agar top integer â†’ return true
  * Agar list â†’ pop & uske elements push karo

### next():

* hasNext() call karo
* Stack.pop().getInteger() return karo

---

# ğŸ” Dry Run (Board Friendly)

### Input:

```
[1,[4,[6]]]
```

### Stack (Top â†’ Bottom)

```
1, [4,[6]]
```

After unfolding:

```
1, 4, [6]
```

Then:

```
1, 4, 6
```

---

# â±ï¸ Complexity

```
Time: O(n)
Space: O(n)
```

Each element processed once.

---

# âœ… Java Code (Lazy Stack Solution)

```java
public class NestedIterator implements Iterator<Integer> {

    private Stack<NestedInteger> stack = new Stack<>();

    public NestedIterator(List<NestedInteger> nestedList) {
        pushListToStack(nestedList);
    }

    private void pushListToStack(List<NestedInteger> list) {
        for (int i = list.size() - 1; i >= 0; i--) {
            stack.push(list.get(i));
        }
    }

    @Override
    public Integer next() {
        hasNext();
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            NestedInteger top = stack.peek();

            if (top.isInteger()) {
                return true;
            }

            stack.pop();
            pushListToStack(top.getList());
        }
        return false;
    }
}
```

---

# ğŸ§  Interview One-Liner

> We use a stack to lazily flatten the nested list, expanding lists only when needed in hasNext(), ensuring optimal performance.

---

# ğŸ§‘â€ğŸ« Board Teaching Flow

### 1ï¸âƒ£ Show nested structure

### 2ï¸âƒ£ Explain why recursion is not ideal

### 3ï¸âƒ£ Introduce stack & lazy flattening

### 4ï¸âƒ£ Dry run stack operations

---

# ğŸŸ¡ Alternative: Eager Flattening (Not Recommended)

* Constructor me pura flatten karo
* next() sirf pointer move kare

âŒ Extra space
âŒ Not lazy

---

# âš ï¸ Common Mistakes

âŒ Forget reverse push
âŒ Flattening in next()
âŒ Not using hasNext() properly

---

# ğŸ”¥ Pattern Recognition

ğŸ“Œ **Lazy Iterator Design**
ğŸ“Œ **Stack-based DFS**

Used in:

* Tree iterators
* Expression parsing
* Nested structures

---

If you want next:

* âœ… Recursive version
* âœ… Python implementation
* âœ… Interview Q&A
* âœ… Visual teaching slides

Just say ğŸš€
