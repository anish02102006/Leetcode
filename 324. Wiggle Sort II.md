Problem Recap ğŸ“Œ
You are given an array nums.
Your task is to rearrange it into a wiggle pattern:

nums[0] < nums[1] > nums[2] < nums[3] ...
To achieve this:

Even indices should contain smaller values
Odd indices should contain larger values
You must modify the array in-place.

Intuition / Approach ğŸ’¡
Observation ğŸ‘€
To avoid equal numbers causing violations in the wiggle pattern, a structured approach works best:

Sort the entire array

Split it into two halves:

First half: smaller numbers
Second half: larger numbers
Fill:

Even indices with values from the end of the smaller half
Odd indices with values from the end of the larger half
Why this works:

Ensures strict alternating pattern
Prevents duplicate conflicts
Guarantees wiggle compliance
Very clean and predictable


Time & Space Complexity â±ï¸ğŸ’¾
Complexity	Explanation


Java


class Solution {


    public void wiggleSort(int[] nums) {
        int n = nums.length;
        int[] v = nums.clone();
        Arrays.sort(v);

        int mid = (n + 1) / 2;
        int left = mid - 1;
        int right = n - 1;

        for (int i = 0; i < n; i++) {
            if (i % 2 == 0)
                nums[i] = v[left--];
            else
                nums[i] = v[right--];
        }
    }
}
Time	O(n log n) â†’ sort
Space	O(n) â†’ extra array
