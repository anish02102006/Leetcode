# Intuition
Since the list is already sorted, duplicate values always appear consecutively.
This allows us to detect duplicates by simply comparing a node with its next node.
If multiple nodes share the same value, we can skip the entire block of duplicates and recursively process the rest of the list.

# Approach
Base Case:
If the list is empty or has only one node, return it as-is.

Duplicate Detection:

Compare head->val with head->next->val.
If equal, store the duplicated value and skip all nodes with that value using a while loop.
Recursive Step:

After skipping duplicates, recursively call the function starting from the next distinct node.
Non-duplicate Case:

If the current node is unique, recursively process the remainder of the list and attach it to head->next.
Return the processed list.

# Complexity
Time Complexity: O(n) â€” each node is visited at most once.
Space Complexity: O(n) due to recursion stack depth.

# Code
class Solution {


    public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next == null) return head;
        if(head.val == head.next.val) {
            int val = head.val;
            while(head != null && head.val == val) 
                head = head.next;
            return deleteDuplicates(head);
        }
        head.next = deleteDuplicates(head.next);
        return head;
    }
}
