Alright ğŸ˜„
**Trionic Array â€“ LeetCode style explanation** coming right up, **full Hinglish**, with **Brute â†’ Better â†’ Optimal**, **intuition + dry run + Java code**.

---

## ğŸ”· Trionic Array kya hota hai?

Ek array **Trionic** hota hai agar usme **3 continuous parts** ho:

1ï¸âƒ£ **Strictly Increasing**
2ï¸âƒ£ **Strictly Decreasing**
3ï¸âƒ£ **Strictly Increasing**

ğŸ“Œ **Important rules**:

* Teeno parts **non-empty** hone chahiye
* Order fixed: â†‘ then â†“ then â†‘
* Continuous segments hone chahiye

### Example:

```
arr = [1, 3, 5, 4, 2, 6, 8]
```

* 1 â†’ 3 â†’ 5  (Increasing)
* 5 â†’ 4 â†’ 2  (Decreasing)
* 2 â†’ 6 â†’ 8  (Increasing)

âœ… Valid Trionic Array

---

## âŒ Invalid Examples:

```
[1,2,3,4]      âŒ (No decreasing part)
[5,4,3,2,1]    âŒ (No increasing parts)
[1,3,2,4]      âŒ (Last increasing too small)
```

---

# ğŸŸ¢ Brute Force Approach (O(nÂ²))

### ğŸ’¡ Intuition:

* Har possible **i, j** split try karo
* Check:

  * `0 â†’ i` increasing
  * `i â†’ j` decreasing
  * `j â†’ n-1` increasing

### âŒ Problem:

* Bahut slow for large `n`
* Mostly conceptual clarity ke liye

### ğŸ§  Steps:

```
for i = 1 to n-3
  for j = i+1 to n-2
    check all 3 segments
```

### ğŸ§ª Dry Run (short):

```
arr = [1,3,5,4,2,6]
i=2, j=4
[1,3,5] â†‘
[5,4,2] â†“
[2,6]   â†‘  âœ…
```

### â˜• Java Code (Brute)

```java
class Solution {
    public boolean isTrionic(int[] arr) {
        int n = arr.length;
        if (n < 4) return false;

        for (int i = 1; i <= n - 3; i++) {
            for (int j = i + 1; j <= n - 2; j++) {

                boolean inc1 = true, dec = true, inc2 = true;

                // first increasing
                for (int k = 1; k <= i; k++)
                    if (arr[k] <= arr[k - 1]) inc1 = false;

                // decreasing
                for (int k = i + 1; k <= j; k++)
                    if (arr[k] >= arr[k - 1]) dec = false;

                // second increasing
                for (int k = j + 1; k < n; k++)
                    if (arr[k] <= arr[k - 1]) inc2 = false;

                if (inc1 && dec && inc2) return true;
            }
        }
        return false;
    }
}
```

---

# ğŸŸ¡ Better Approach (O(n))

### ğŸ’¡ Intuition:

* Ek hi traversal me **trend detect** karo
* Phases ko count karo:

  * Phase 1 â†’ Increasing
  * Phase 2 â†’ Decreasing
  * Phase 3 â†’ Increasing

### ğŸ§  Idea:

* Pointer move karo
* Har phase me **at least ek move** hona chahiye

---

### ğŸ§ª Dry Run:

```
arr = [1,3,5,4,2,6]

i=0
Phase1: 1â†’3â†’5 âœ”
Phase2: 5â†’4â†’2 âœ”
Phase3: 2â†’6 âœ”
End reached â†’ TRUE
```

---

### â˜• Java Code (Better)

```java
class Solution {
    public boolean isTrionic(int[] arr) {
        int n = arr.length;
        if (n < 4) return false;

        int i = 0;

        // Phase 1: increasing
        while (i + 1 < n && arr[i] < arr[i + 1]) i++;
        if (i == 0 || i == n - 1) return false;

        // Phase 2: decreasing
        int peak = i;
        while (i + 1 < n && arr[i] > arr[i + 1]) i++;
        if (i == peak || i == n - 1) return false;

        // Phase 3: increasing
        while (i + 1 < n && arr[i] < arr[i + 1]) i++;

        return i == n - 1;
    }
}
```

â± **Time:** O(n)
ğŸ“¦ **Space:** O(1)

---

# ğŸ”¥ Optimal Approach (Same as Better â€“ Clean Logic)

Actually **Better = Optimal** here
But interview me tum ise **state-machine approach** bol sakte ho ğŸ’ª

### ğŸ§  State Concept:

```
state = 0 â†’ increasing
state = 1 â†’ decreasing
state = 2 â†’ increasing
```

### â˜• Java Code (Optimal â€“ State Based)

```java
class Solution {
    public boolean isTrionic(int[] arr) {
        int n = arr.length;
        if (n < 4) return false;

        int state = 0; // 0-inc, 1-dec, 2-inc

        for (int i = 1; i < n; i++) {
            if (state == 0) {
                if (arr[i] > arr[i - 1]) continue;
                else if (arr[i] < arr[i - 1]) state = 1;
                else return false;
            }
            else if (state == 1) {
                if (arr[i] < arr[i - 1]) continue;
                else if (arr[i] > arr[i - 1]) state = 2;
                else return false;
            }
            else {
                if (arr[i] <= arr[i - 1]) return false;
            }
        }
        return state == 2;
    }
}
```

---

## ğŸ§  Interview Tip:

Agar interviewer bole:

> â€œExplain intuitionâ€

Bolna ğŸ‘‡

> â€œHum array ko ek hi traversal me teen monotonic phases me tod rahe hain â€” pehle increasing, phir decreasing, aur phir dobara increasing. Har phase me kam se kam ek element hona mandatory hai.â€

---

Agar chaho to next step me mai:

* ğŸ”¥ **LeetCode exact problem link**
* âœï¸ **Edge cases list**
* ğŸ¯ **Follow-up questions**
* ğŸ“Š **Visualization diagram**

bhi kara deta hoon ğŸ˜„
