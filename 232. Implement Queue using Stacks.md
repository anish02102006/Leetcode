Chalo bhai ğŸ˜„
**LeetCode 232 â€“ Implement Queue using Stacks** ko **bilkul crystal clear** kar dete hain â€” **Brute / Better / Optimal** style me **Java + Hinglish** ğŸ”¥

---

## ğŸ”´ Problem Samajh Lo

Tumhe **Queue (FIFO)** implement karni hai
lekin sirf **Stack ke operations** use kar sakte ho.

### Queue Ops

* `push(x)`  ğŸ‘‰ enqueue
* `pop()`    ğŸ‘‰ dequeue
* `peek()`   ğŸ‘‰ front
* `empty()`

### Stack Ops Allowed

* `push`
* `pop`
* `peek`
* `isEmpty`
* `size`

---

# ğŸŸ  Approach 1: Two Stacks (Push Costly)

### ğŸ§  Idea

* Hamesha **front element ko top** pe rakho

---

### ğŸ”„ Push Logic

1. `stack1 â†’ stack2`
2. new element push karo in `stack1`
3. `stack2 â†’ stack1`

---

### âœ… Java Code (Push Costly)

```java
import java.util.*;

class MyQueue {

    Stack<Integer> s1 = new Stack<>();
    Stack<Integer> s2 = new Stack<>();

    public void push(int x) {
        while (!s1.isEmpty()) {
            s2.push(s1.pop());
        }

        s1.push(x);

        while (!s2.isEmpty()) {
            s1.push(s2.pop());
        }
    }

    public int pop() {
        return s1.pop();
    }

    public int peek() {
        return s1.peek();
    }

    public boolean empty() {
        return s1.isEmpty();
    }
}
```

---

### â± Time

| Operation | Time |
| --------- | ---- |
| push      | O(n) |
| pop       | O(1) |
| peek      | O(1) |
| empty     | O(1) |

---

# ğŸŸ¡ Approach 2: Two Stacks (Pop Costly)

### ğŸ§  Idea

* Enqueue fast rakho
* Jab pop/peek chahiye tab reverse order banao

---

### ğŸ”„ Working

* `inStack` â†’ push elements
* `outStack` â†’ pop/peek elements

---

### âœ… Java Code (Better)

```java
import java.util.*;

class MyQueue {

    Stack<Integer> in = new Stack<>();
    Stack<Integer> out = new Stack<>();

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
        return out.pop();
    }

    public int peek() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
        return out.peek();
    }

    public boolean empty() {
        return in.isEmpty() && out.isEmpty();
    }
}
```

---

### â± Time

| Operation | Time           |
| --------- | -------------- |
| push      | O(1)           |
| pop       | Amortized O(1) |
| peek      | Amortized O(1) |
| empty     | O(1)           |

ğŸ”¥ **Interview Favorite**

---

# ğŸŸ¢ Approach 3: Single Stack (Not Recommended âŒ)

* Theoretically possible using recursion
* LeetCode + Interview me **avoid karo**

---

## ğŸ§  Dry Run (Approach 2)

```
push(1) â†’ in = [1]
push(2) â†’ in = [1,2]

pop():
out empty â†’ transfer
out = [2,1]
pop â†’ 1
```

---

## ğŸ¯ Interview Tip (Bolne Layak Line)

> â€œSir, two stacks approach me push O(1) hota hai aur pop amortized O(1), jo optimal hai.â€

---

## ğŸ§© Related Questions

* 225. Stack using Queues
* 155. Min Stack
* 20. Valid Parentheses

---

Agar chaaho to mai:

* **Visualization**
* **Amortized time explanation**
* **One-liner interview explanation**
* **Common mistakes**

sab cover karwa dunga ğŸ’ª
Bas bolo bhai ğŸ”¥
