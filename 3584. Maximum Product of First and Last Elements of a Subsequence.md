# Key Insight
In a subsequence of size m, we only care about the first and last elements. The middle m - 2 elements can be any elements between them (as long as the order is preserved).

So for any pair (i, j) such that j - i + 1 ≥ m, we can pick:

nums[i] as the first
nums[j] as the last
And that forms a valid subsequence of length m.

#  Goal
Find the maximum value of nums[i] * nums[j]
where j - i + 1 ≥ m.

# Line-by-Line Explanation
ma keeps the maximum start value of a potential subsequence.

mi keeps the minimum start value (needed because of negative numbers).

Start looping from i = m to the end of the array:

A[i - m + 1] is the first element of a valid subsequence of size m ending at A[i].

Update ma and mi with this value.

Check both ma * A[i] and mi * A[i], and update the result.

#  Complexity
Time: O(n - m)
Space: O(1)

# Code
    public long maximumProduct(int[] A, int m) {
        long ma = A[0], mi = A[0], res = 1L * A[0] * A[m - 1];
        for (int i = m; i < A.length; ++i) {
            ma = Math.max(ma, A[i - m + 1]);
            mi = Math.min(mi, A[i - m + 1]);
            res = Math.max(res, Math.max(mi * A[i], ma * A[i]));
        }
        return res;
    }
