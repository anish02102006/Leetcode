# Intuition
In a balanced binary search Tree height difference b/w left and right node cannot be more than 1 or in other words they contain almost equal number of nodes.

This can be achieved by dividing the Linked List into 2 parts first half = left Node, middle = root and right = second half. Repeat the above process recursively to generate the BST.

To find middle element use 2 pointer approach: The fast moves 2 steps and slow 1 step at a time. Hence when fast is finished, slow will be at middle.

eg: Find the middle element below = 0 and form root. The LinkedList on left of middle will form a new BST and right will form a new BST using same function. i.e -3 will be mid and left = -10 and right = -1 .
image

image

# Approach
Find the middle element of the linked list.
Create a new node with the middle element as its value.
Set the left subtree of the new node to the result of recursively calling the function on the left half of the sorted list.
Set the right subtree of the new node to the result of recursively calling the function on the right half of the sorted list.
Return the new node.
How to find middle element:

Initialize two pointers, slow and fast, to head.
Move fast two steps ahead and slow one step ahead, until fast reaches the end of the list or goes past it.
The element pointed to by slow is the middle element of the list.

# Code 
class Solution {


    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) return null;
        if(head.next == null) return new TreeNode(head.val);
        ListNode middle = getMiddle(head);
        TreeNode root = new TreeNode(middle.val);
        root.right = sortedListToBST(middle.next);
        middle.next =null;
        root.left = sortedListToBST(head);
        return root;
    }
    
    public ListNode getMiddle(ListNode head){
        //if(head == null || head.next==null) return null;
        ListNode fast = head;
        ListNode slow = head;
        ListNode prev = null;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            prev = slow;
            slow = slow.next;
            
        }
        if(prev!=null)prev.next =null;
        return slow;
    }
}
