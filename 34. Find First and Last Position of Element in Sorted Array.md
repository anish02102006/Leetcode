Perfect ğŸ‘
**LeetCode 34 â€“ Find First and Last Position of Element in Sorted Array**
This is a **classic Binary Search + boundaries problem**.
Iâ€™ll explain it **teacher-style, Hinglish**, exactly how you can explain on board / digital pad.

---

# ğŸ§  Problem Samajh Lo

Tumhe ek **sorted array** diya gaya hai `nums`
Aur ek `target` value.

ğŸ‘‰ Tumhe **target ka first (leftmost)**
ğŸ‘‰ Aur **last (rightmost) position** nikalni hai

Agar target exist nahi karta â†’ return `[-1, -1]`

---

### Example

```
nums = [5,7,7,8,8,10]
target = 8

Output = [3, 4]
```

---

# ğŸŸ¥ Brute Force Approach

## ğŸ§  Idea

* Pure array ko scan karo
* Jahan target mile â†’ update first & last index

```text
for i = 0 â†’ n-1
    if nums[i] == target
        if first == -1 â†’ first = i
        last = i
```

â±ï¸ Time: `O(n)`
ğŸ“¦ Space: `O(1)`

âŒ But array sorted hai â†’ better approach possible

---

# ğŸŸ¡ Better Approach (Binary Search + Expand)

1. Binary search se ek occurrence find karo
2. Left & right expand karo

âŒ Worst case `O(n)`

---

# ğŸŸ¢ Optimal Approach (Two Binary Searches) ğŸ”¥

## ğŸ’¡ Core Intuition

Binary Search ka use karke:

* Ek baar **first occurrence**
* Ek baar **last occurrence**

---

# ğŸ” Binary Search Logic

### For First Occurrence:

* Agar `nums[mid] == target`

  * Answer store karo
  * Left side search karo (`high = mid - 1`)

### For Last Occurrence:

* Agar `nums[mid] == target`

  * Answer store karo
  * Right side search karo (`low = mid + 1`)

---

# â±ï¸ Complexity

```
Time: O(log n)
Space: O(1)
```

---

# âœ… Java Code (Clean & Interview Ready)

```java
class Solution {

    public int[] searchRange(int[] nums, int target) {
        int first = findFirst(nums, target);
        int last = findLast(nums, target);
        return new int[]{first, last};
    }

    private int findFirst(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        int ans = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] == target) {
                ans = mid;
                high = mid - 1; // left search
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }

    private int findLast(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        int ans = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] == target) {
                ans = mid;
                low = mid + 1; // right search
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }
}
```

---

# ğŸ§‘â€ğŸ« Board Explanation (Step-by-Step)

### Step 1:

Write array & target

### Step 2:

Explain:

> â€œNormal binary search milte hi ruk jata hai
> But hume **boundary** chahiyeâ€

### Step 3:

Dry run for `first occurrence`

### Step 4:

Dry run for `last occurrence`

---

# ğŸ“Œ Dry Run (First Occurrence)

```
nums = [5,7,7,8,8,10]
target = 8

mid = 3 â†’ found
ans = 3
high = mid - 1 â†’ search left
```

---

# ğŸ§  Interview One-Liner

> Since the array is sorted, we use two binary searches to find the leftmost and rightmost occurrences in O(log n) time.

---

# ğŸ”¥ Common Mistakes (Tell Students)

âŒ Using linear scan
âŒ Stopping binary search after first match
âŒ Not updating `ans`

---

# ğŸŸ¢ Pattern Name (Important for DSA)

ğŸ“Œ **Binary Search on Boundaries**
ğŸ“Œ Also used in:

* Lower Bound
* Upper Bound
* First Bad Version

---

If you want next:

* âœ… Lower Bound vs Upper Bound
* âœ… Binary Search template
* âœ… Animated dry run
* âœ… LeetCode 33 / 35 / 704

Just say ğŸš€
