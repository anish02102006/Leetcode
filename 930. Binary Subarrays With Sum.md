Chalo bhai ğŸ˜„
**LeetCode 930 â€“ Binary Subarrays With Sum** ko **A to Z** samajhte hain â€” **Brute â†’ Better â†’ Optimal**, **Java code ke saath**, aur **pure Hinglish** me.

---

## ğŸ”´ Problem Samajh Lo (Simple Words)

Tumhe ek **binary array** diya hai (sirf `0` aur `1`)
aur ek number `goal`.

ğŸ‘‰ Tumhe count karna hai **kitne subarrays** ka **sum = goal** hai.

### Example

```
nums = [1,0,1,0,1]
goal = 2
```

Valid subarrays:

```
[1,0,1]
[1,0,1,0]
[0,1,0,1]
[1,0,1]
```

ğŸ‘‰ Answer = **4**

---

# ğŸŸ  Approach 1: Brute Force (O(nÂ²))

### ğŸ§  Idea

* Har possible subarray try karo
* Uska sum nikalo
* Agar sum == goal â†’ count++

### âŒ Problem

* Large input me **TLE** aayega

---

### âœ… Java Code (Brute)

```java
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int count = 0;

        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum == goal) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

### â± Time: `O(nÂ²)`

### ğŸ“¦ Space: `O(1)`

---

# ğŸŸ¡ Approach 2: Better (Prefix Sum + HashMap) â€“ O(n)

### ğŸ§  Core Idea

* **Prefix Sum** ka concept use karo
* Agar:

```
prefixSum - goal pehle aaya ho
```

ğŸ‘‰ to ek valid subarray exist karta hai

---

### ğŸ“ Math Logic

```
sum(i to j) = prefix[j] - prefix[i-1]
prefix[j] - prefix[i-1] = goal
prefix[i-1] = prefix[j] - goal
```

---

### âœ… Java Code (Better)

```java
import java.util.*;

class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);   // important

        int prefixSum = 0;
        int count = 0;

        for (int num : nums) {
            prefixSum += num;

            if (map.containsKey(prefixSum - goal)) {
                count += map.get(prefixSum - goal);
            }

            map.put(prefixSum, map.getOrDefault(prefixSum, 0) + 1);
        }

        return count;
    }
}
```

### â± Time: `O(n)`

### ğŸ“¦ Space: `O(n)`

---

# ğŸŸ¢ Approach 3: Optimal (Sliding Window Trick) â€“ O(n)

âš ï¸ **Important:**
Direct sliding window kaam **nahi karta** kyunki zeros hai.

### ğŸ”¥ Trick:

```
Subarrays with sum = goal
= Subarrays with sum â‰¤ goal
- Subarrays with sum â‰¤ goal-1
```

---

## Helper Function: Sum â‰¤ K

### ğŸ§  Sliding Window

* Right pointer aage badhao
* Agar sum > k â†’ left aage badhao
* Har step pe `(right - left + 1)` add karo

---

### âœ… Java Code (Optimal)

```java
class Solution {

    private int countAtMost(int[] nums, int k) {
        if (k < 0) return 0;

        int left = 0, sum = 0, count = 0;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];

            while (sum > k) {
                sum -= nums[left];
                left++;
            }

            count += (right - left + 1);
        }
        return count;
    }

    public int numSubarraysWithSum(int[] nums, int goal) {
        return countAtMost(nums, goal) - countAtMost(nums, goal - 1);
    }
}
```

---

### â± Time: `O(n)`

### ğŸ“¦ Space: `O(1)`

ğŸ”¥ **Most Optimal**

---

## ğŸ§  Summary Table

| Approach             | Time  | Space | Interview Use |
| -------------------- | ----- | ----- | ------------- |
| Brute                | O(nÂ²) | O(1)  | âŒ             |
| Prefix + Map         | O(n)  | O(n)  | âœ…             |
| Sliding Window Trick | O(n)  | O(1)  | ğŸ”¥ BEST       |

---

## ğŸ¯ Interview Tip

Agar interviewer bole:

> **Binary array hai**

Seedha bolo:

> "Sir, sliding window ka optimized trick use kar sakte hain using `atMost(goal)`"

---

Agar chaaho to mai:

* **Dry run**
* **Visual explanation**
* **LeetCode follow-up questions**
* **Similar problems list**

sab karwa dunga ğŸ˜
Bas bolo bhai ğŸ‘Š
