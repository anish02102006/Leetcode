Here‚Äôs a **deep explanation** of **LeetCode 2147: Number of Ways to Divide a Long Corridor** with **brute-force, better, and optimal approaches**, and a **clean optimal Java solution** you can use. ([LeetCode The Hard Way][1])

---

## üîç Problem Summary

You are given a string `corridor` of length *n* with:

* `'S'` = seat
* `'P'` = plant

There is already **one divider at the start** (before index 0) and **one at the end** (after index *n‚àí1*).
You can place additional dividers between adjacent positions.

You must divide the corridor into sections such that:

* Each **section has exactly two seats**,
* Sections can contain **any number of plants**,
* You count how many **distinct ways** you can install dividers.

Return the number of ways modulo **10‚Åπ + 7**.
If no valid division exists, return **0**.

Example:
Input: `"SSPPSPS"` ‚Üí Output: **3** because there are 3 valid ways to place dividers. ([Ada He][2])

---

## üß† Key Insight

To make any valid division:

* Every section must contain **exactly 2 seats**.
* If the total number of seats in the entire corridor is not **even** (or is less than 2), answer is **0**.
* Between two adjacent ‚Äúgroups‚Äù of two seats, the number of **plants** in between determines how many ways you can place separators.

Consider:
If between two groups of seats you have **k plants**, then there are **k + 1** positions you could place a single divider.
Multiply all such `(k + 1)` factors across the corridor to get the result.

üí° This is the **optimal** calculation method.

---

## üßæ Approaches

---

### üö´ 1) Brute-Force (Exponential Backtracking)

You could try:

* Try every subset of positions between characters as possible divider placements.
* For each, simulate sections and check if **every section has exactly 2 seats**.

But this would be **O(2‚Åø)** and totally infeasible for n up to 10‚Åµ.

This brute approach is **theoretical** only.

---

### ‚ö†Ô∏è 2) Naive Recursive / DP

Another way would be:

Define a state `dfs(i, currentSeatCount)` = number of ways to partition from index `i` with `currentSeatCount` seats in the current segment.

Then:

* If you see `'S'`: increment seat count.
* If seat count > 2: invalid ‚Üí return 0.
* Recurse with/without placing a divider when seat count == 2.

This is a **recursive DP** with memoization, and it runs in **O(n)** because there are at most `3√ón` states (`i` from 0..n, seatCount in {0,1,2}). ([AlgoMonster][3])

This works but is more complex than needed.

---

### ‚úÖ 3) **Optimal (Greedy / Combinatorial)**

**Steps**

1. Traverse the string.
2. Count seats until you get 2 ‚Üí this marks the end of a block.
3. After having 2 seats, start counting plants right after them.
4. When you hit the **3rd seat**, you have completed one full block and are starting the next block:

   * Multiply the ways by `plantsBetween + 1`.
   * Reset plant counter.
5. At the end, if the last block has not exactly 2 seats, return 0.
6. Return the product modulo **10‚Åπ + 7**.

**Time:** O(n)
**Space:** O(1) ([Ada He][2])

---

## ‚úÖ Optimal Java Code

```java
class Solution {
    public int numberOfWays(String corridor) {
        final long MOD = 1_000_000_007L;
        
        long ways = 1, seats = 0, plants = 0;
        
        for (int i = 0; i < corridor.length(); i++) {
            char c = corridor.charAt(i);
            
            // Count seats
            if (c == 'S') {
                seats++;
            } else {
                // Only count plants once we have exactly 2 seats collected
                if (seats == 2) {
                    plants++;
                }
            }
            
            // Whenever we hit the 3rd seat, that means
            // we close previous block and start a new one
            if (seats == 3) {
                ways = (ways * (plants + 1)) % MOD;
                seats = 1;   // Current 'S' becomes first seat of next block
                plants = 0;  // Reset plant count between blocks
            }
        }
        
        // If the last block does not have exactly 2 seats, impossible
        return (seats == 2) ? (int) (ways % MOD) : 0;
    }
}
```

---

## üìå Example Walkthrough

Input: `"SSPPSPS"`

Positions:

```
0 S  
1 S  => first block is [SS]
2 P
3 P
4 S => second block starts
5 P
6 S => second block ends
```

Between the two blocks:

* Seats at positions: 0,1 ‚Üí first block
* Seats at 4,6 ‚Üí second block
* Plants between them = positions 2 & 3 ‚Üí count = 2

Ways to place a divider = `plantsBetween + 1 = 3`

So result = **3**.

---

## üî¢ Time & Space

| Approach                 | Time     | Space    |                              |
| ------------------------ | -------- | -------- | ---------------------------- |
| Brute-Force              | O(2‚Åø)    | O(n)     |                              |
| Recursive DP             | O(n)     | O(n)     |                              |
| **Optimal Divider Math** | **O(n)** | **O(1)** | ([LeetCode The Hard Way][1]) |

---

## üß† Final Notes

‚úî Always check **total seats** first ‚Äî if odd ‚Üí return 0
‚úî Only sections with exactly **2 seats** are valid
‚úî Plants between seat pairs give you **choices** (`+1`)

---

If you want, I can also provide a similar Python or C++ implementation too!

[1]: https://leetcodethehardway.com/solutions/2100-2199/number-of-ways-to-divide-a-long-corridor-hard?utm_source=chatgpt.com "2147 - Number of Ways to Divide a Long Corridor (Hard) | LeetCode The Hard Way"
[2]: https://www.ada-he.com/en/LeetCode-2147-Number-of-Ways-to-Divide-a-Long-Corridor/?utm_source=chatgpt.com "Hard | LeetCode 2147. Number of Ways to Divide a Long Corridor | Ada He"
[3]: https://algo.monster/liteproblems/2147?utm_source=chatgpt.com "2147. Number of Ways to Divide a Long Corridor - In-Depth Explanation"
