Chalo ğŸ”¥
**LeetCode 424 â€“ Longest Repeating Character Replacement** ko **interview-level clarity** ke saath samajhte hain
ğŸ‘‰ **Brute â†’ Better â†’ Optimal (Sliding Window)**
ğŸ‘‰ **Hinglish explanation + intuition + Java code + dry run**

---

## ğŸ§  Problem Samajh Lo

Tumhe ek **string `s`** (sirf uppercase letters) aur ek integer **`k`** diya hai.

ğŸ‘‰ Tum **maximum length ka substring** find karo jisme:

* Tum **at most `k` characters replace** kar sakte ho
* Taaki substring ke **saare characters same ho jaayein**

---

### Example:

```
s = "AABABBA"
k = 1
```

Possible:

```
"AABA" â†’ replace B â†’ A
"ABBA" â†’ replace A â†’ B
```

ğŸ‘‰ **Answer = 4**

---

## ğŸ”‘ Key Observation

Substring valid tab hoga jab:

```
window_length - max_frequency_in_window <= k
```

Kyuki:

* `max_frequency` = jo character sabse zyada baar aa raha
* Baaki characters ko replace karna padega

---

# ğŸŸ¥ Brute Force Approach

## ğŸ’¡ Idea:

* Har substring consider karo
* Uska frequency count nikalo
* Check karo kitne replacements chahiye

---

### âŒ Java Code (Brute)

```java
class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLen = 0;

        for (int i = 0; i < n; i++) {
            int[] freq = new int[26];
            int maxFreq = 0;

            for (int j = i; j < n; j++) {
                freq[s.charAt(j) - 'A']++;
                maxFreq = Math.max(maxFreq, freq[s.charAt(j) - 'A']);

                if ((j - i + 1) - maxFreq <= k) {
                    maxLen = Math.max(maxLen, j - i + 1);
                }
            }
        }
        return maxLen;
    }
}
```

â± **Time:** O(NÂ² Ã— 26)
ğŸ“¦ **Space:** O(26)
âŒ TLE for large inputs

---

# ğŸŸ¡ Better Approach

* Same logic
* Frequency reuse
* Still O(NÂ²)

ğŸ‘‰ Not interview-friendly

---

# ğŸŸ¢ Optimal Approach (Sliding Window)

ğŸ”¥ **Most important sliding window problem**

---

## ğŸ’¡ Core Idea:

* Window maintain karo
* Frequency array rakho
* Track karo **max repeating character count**
* Window tab tak valid jab:

```
window_size - maxFreq <= k
```

---

## ğŸ§  Sliding Window Steps:

1. `left = 0`
2. `freq[26]`
3. `maxFreq = 0`
4. `right` badhao
5. Agar invalid â†’ `left++`

---

### ğŸ§ª Dry Run (Short)

```
s = "AABABBA", k = 1

Window: "AABA"
Freq(A)=3, B=1
4 - 3 = 1 â‰¤ k âœ”
```

---

### âœ… Java Code (Optimal)

```java
class Solution {
    public int characterReplacement(String s, int k) {
        int[] freq = new int[26];
        int left = 0;
        int maxFreq = 0;
        int maxLen = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            freq[c - 'A']++;
            maxFreq = Math.max(maxFreq, freq[c - 'A']);

            while ((right - left + 1) - maxFreq > k) {
                freq[s.charAt(left) - 'A']--;
                left++;
            }

            maxLen = Math.max(maxLen, right - left + 1);
        }
        return maxLen;
    }
}
```

---

### â± Complexity:

* **Time:** O(N)
* **Space:** O(26) â†’ O(1)

â­ Interview favorite
â­ Amazon / Google / Microsoft standard

---

## â“ Important Doubt (Interview Trick Question)

**Q: maxFreq kabhi kam kyu nahi karte?**

ğŸ‘‰ Kyuki:

* maxFreq sirf **window expand** hone pe update hota
* Thoda inaccurate ho sakta hai, but window size kabhi galat answer nahi dega
* Overall correctness maintain hoti hai

---

# ğŸ“Š Comparison Table

| Approach       | Time  | Space | Verdict |
| -------------- | ----- | ----- | ------- |
| Brute          | O(NÂ²) | O(1)  | âŒ       |
| Sliding Window | O(N)  | O(1)  | â­ BEST  |

---

## ğŸ¯ Interview One-Liner

> â€œWe use a sliding window where we keep track of the most frequent character, and ensure that replacements needed are at most k.â€

---

Agar chaho:

* ğŸ§  **Deep intuition**
* ğŸ” **Full dry run table**
* ğŸ§ª **Edge cases**
* ğŸ”— **Related sliding window problems list**

Bas bol do ğŸ˜„
