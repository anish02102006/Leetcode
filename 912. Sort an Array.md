# Intuition
When we have a limited range of integers to sort, we can use their values directly to determine their position in the sorted array. This is the core idea behind Counting Sort. Instead of comparing elements, we count how many times each number appears and use this information to place the numbers in the correct order.

# Approach
The Counting Sort algorithm we've implemented follows a straightforward yet efficient method to sort an array of integers within a specific range. We begin by scanning through the entire input array to identify the minimum and maximum values. This step is crucial as it allows us to determine the range of numbers we're dealing with, which in turn helps us optimize our space usage.

Once we have this range, we create a counting array. The size of this array is equal to the difference between the maximum and minimum values, plus one. Each index in this counting array corresponds to a number in our input range, offset by the minimum value. We then proceed to count the occurrences of each number in the original array. This is done by iterating through the input array once more, and for each number, we increment the count at the corresponding index in our counting array.

After the counting phase, we have a complete tally of how many times each number appears in our input. The final step is to reconstruct the sorted array. We do this by iterating through our counting array. For each index, we know that the number it represents (index plus minimum value) should appear in our sorted array as many times as the count stored at that index. We use this information to place each number in its correct position in the original array, effectively sorting it in-place.

This approach is particularly efficient for arrays with a limited range of integers, as it avoids comparisons between elements and instead uses the integer values directly to determine their positions. The algorithm's efficiency comes from the fact that it makes only a few passes through the data, regardless of how unsorted it initially was.

# Complexity
Time complexity: O(n + k)
Where n is the number of elements in the input array, and k is the range of input (max - min + 1).
We go through the array twice (once to count, once to place elements) and once through the counting array.

Space complexity: O(k)
We use extra space for the counting array, which has a size equal to the range of input values.

# Code
class Solution {

    public int[] sortArray(int[] nums) {
        if (nums == null || nums.length <= 1) return nums;
        
        int max = nums[0], min = nums[0];
        for (int num : nums) {
            if (num > max) max = num;
            if (num < min) min = num;
        }
        
        int range = max - min + 1;
        int[] count = new int[range];
        
        for (int num : nums) {
            count[num - min]++;
        }
        
        int index = 0;
        for (int i = 0; i < range; i++) {
            int freq = count[i];
            if (freq > 0) {
                int value = i + min;
                while (freq-- > 0) {
                    nums[index++] = value;
                }
            }
        }
        
        return nums;
    }
}
