# Intuition
The array is not sorted.
We are allowed to repeatedly merge two adjacent elements into their sum.
Each merge removes one element from the array.

So:
Keep merging adjacent pairs with the smallest sum, because merging the "cheapest" pair causes the least disturbance to the ordering.
Repeat until the entire list becomes sorted.

# Approach
Convert the array into a List for easy removal and replacement.
While the list is not sorted:
Scan all adjacent pairs.
Compute their sum.
Pick the pair with the minimum sum.
Merge them (replace left value with the sum, remove the right value).
Increase the merge counter.
When the list becomes sorted, return the number of merges.
The helper function sorted() checks if the list is non-decreasing.

# Complexity
Time complexity: Worst case: O(n^3) -
Because each merge costs O(n),
sorting check costs O(n),
and up to O(n) merges.

Space Complexity: O(n) - We store the array inside a dynamic list.

# Code
class Solution {


    public int minimumPairRemoval(int[] nums) {
        List <Integer> list = new ArrayList<>();
        for(int i:nums)
        {
            list.add(i);
        }

        int count = 0;

        // Keep merging until the list becomes sorted
        while(!sorted(list))
        {
            int idx = 0;
            int minSum = Integer.MAX_VALUE;

            // Find adjacent pair with the smallest sum
            for(int i=0;i<list.size()-1;i++)
            {
                int sum = list.get(i)+list.get(i+1);
                if(sum<minSum)
                {
                    minSum = sum;
                    idx = i;
                }
            }

            // Merge the chosen pair
            int merged = list.get(idx)+list.get(idx+1);
            list.set(idx,merged);
            list.remove(idx+1);
            count++;
        }
        return count;
    }

    // Check if list is sorted
    private boolean sorted(List<Integer> list)
    {
        for(int i=1;i<list.size();i++)
        {
            if(list.get(i)<list.get(i-1))
            {
                return false;
            }
        }
        return true;
    }
}
