# Intuition
The main challenge in this problem is handling the random pointers. When we're creating a copy of a node, its random pointer might reference a node that we haven't created yet, or it might reference a node we've already passed.

Consider what happens if we try to copy the list in a single pass: When we copy node A, and A's random pointer points to node C (which comes later in the list), we can't set up this connection yet because node C's copy doesn't exist. Similarly, if A's random pointer points backwards to a previously copied node, we need a way to find that copied node.

This naturally leads us to think about maintaining a mapping between original nodes and their copies. A hash table is perfect for this - it gives us O(1) access to find any copied node given its original.

The solution becomes clear: we need two passes through the list:

First pass: Create all the new nodes and establish the mapping. While we're at it, we can connect the next pointers since they follow a sequential pattern.
Second pass: Now that all nodes are created and we have our mapping, we can properly set up the random pointers. For each original node, we look up its copy, then set the copy's random pointer to point to the copy of wherever the original's random points.
The key insight is that we must separate node creation from random pointer assignment. The hash table serves as the bridge between the original and copied lists, allowing us to translate any reference from the original list to its corresponding reference in the copied list.


# Solution Approach
The implementation uses a hash table to maintain the mapping between original nodes and their copies. Here's the step-by-step walkthrough:

Initialization:

Create a dummy head node dummy to simplify list construction
Use a tail pointer initialized to dummy to track where to append new nodes
Initialize an empty dictionary d to store the mapping between original and copied nodes
Set cur pointer to the original list's head
First Pass - Node Creation and Next Pointer Setup:

while cur:
    node = Node(cur.val)      # Create a new node with same value
    tail.next = node           # Connect to the previous copied node
    tail = tail.next           # Move tail to the newly created node
    d[cur] = node             # Store mapping: original -> copy
    cur = cur.next            # Move to next original node
During this pass:

We traverse the original list once
For each original node, we create a corresponding new node with the same value
We build the next pointer chain for the copied list
We populate the hash table d where keys are original nodes and values are their copies
Second Pass - Random Pointer Setup:

cur = head                    # Reset to start of original list
while cur:
    d[cur].random = d[cur.random] if cur.random else None
    cur = cur.next
During this pass:

We traverse the original list again
For each original node, we access its copy via d[cur]
We set the copy's random pointer by looking up where the original's random points
If cur.random exists, we use d[cur.random] to get the corresponding copied node
If cur.random is None, we set the copy's random to None as well
Return the Result:

Return dummy.next, which is the head of the deep copied list
The time complexity is O(n) where n is the number of nodes (two passes through the list), and the space complexity is O(n) for the hash table storing the node mappings.

Ready to land your dream job?
Unlock your dream job with a 5-minute evaluator for a personalized learning plan!
Example Walkthrough
Let's walk through a small example with 3 nodes to illustrate the solution approach.

Original List:

Node 1 (val=7) -> Node 2 (val=13) -> Node 3 (val=11) -> null
Random pointers:
- Node 1.random -> null
- Node 2.random -> Node 1
- Node 3.random -> Node 2
Step-by-step execution:

Initialization:

Create dummy node (helper node for building the copy)
tail = dummy (points to where we'll append next)
d = {} (empty hash table)
cur = head (points to Node 1)
First Pass - Creating nodes and setting next pointers:

Iteration 1: cur points to Node 1 (val=7)

Create new Node 1' with val=7
tail.next = Node 1' (dummy -> Node 1')
tail = Node 1'
d[Node 1] = Node 1' (store mapping)
cur = cur.next (move to Node 2)
Iteration 2: cur points to Node 2 (val=13)

Create new Node 2' with val=13
tail.next = Node 2' (Node 1' -> Node 2')
tail = Node 2'
d[Node 2] = Node 2' (store mapping)
cur = cur.next (move to Node 3)
Iteration 3: cur points to Node 3 (val=11)

Create new Node 3' with val=11
tail.next = Node 3' (Node 2' -> Node 3')
tail = Node 3'
d[Node 3] = Node 3' (store mapping)
cur = cur.next (becomes null, exit loop)
After First Pass:

Copied list structure: Node 1' -> Node 2' -> Node 3' -> null
Hash table d:
{
  Node 1 -> Node 1',
  Node 2 -> Node 2',
  Node 3 -> Node 3'
}
Second Pass - Setting random pointers:

Iteration 1: cur points to Node 1

cur.random is null
Set d[Node 1].random = None (Node 1'.random = null)
cur = cur.next (move to Node 2)
Iteration 2: cur points to Node 2

cur.random points to Node 1
Set d[Node 2].random = d[Node 1] (Node 2'.random = Node 1')
cur = cur.next (move to Node 3)
Iteration 3: cur points to Node 3

cur.random points to Node 2
Set d[Node 3].random = d[Node 2] (Node 3'.random = Node 2')
cur = cur.next (becomes null, exit loop)
Final Result: The deep copied list has the structure:

Node 1' (val=7) -> Node 2' (val=13) -> Node 3' (val=11) -> null
Random pointers:
- Node 1'.random -> null
- Node 2'.random -> Node 1'
- Node 3'.random -> Node 2'
The function returns dummy.next, which is Node 1', the head of our deep copied list. Notice how all the pointers in the copied list point to copied nodes, not the original ones, achieving a true deep copy.

code:

/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {


    public Node copyRandomList(Node head) {
        // HashMap to store mapping from original nodes to copied nodes
        Map<Node, Node> oldToNewMap = new HashMap<>();
      
        // Create a dummy node to simplify list construction
        Node dummyHead = new Node(0);
        Node currentTail = dummyHead;
      
        // First pass: Create all nodes and build the next pointers
        // Also populate the mapping from original to copied nodes
        for (Node currentOriginal = head; currentOriginal != null; currentOriginal = currentOriginal.next) {
            // Create a new node with the same value as the original
            Node newNode = new Node(currentOriginal.val);
          
            // Connect the new node to the copied list
            currentTail.next = newNode;
            currentTail = newNode;
          
            // Store the mapping from original node to copied node
            oldToNewMap.put(currentOriginal, newNode);
        }
      
        // Second pass: Set the random pointers for all copied nodes
        for (Node currentOriginal = head; currentOriginal != null; currentOriginal = currentOriginal.next) {
            // Get the corresponding copied node
            Node copiedNode = oldToNewMap.get(currentOriginal);
          
            // Set the random pointer of the copied node
            // If original's random is null, set to null; otherwise, get the corresponding copied node
            copiedNode.random = (currentOriginal.random == null) ? null : oldToNewMap.get(currentOriginal.random);
        }
      
        // Return the head of the copied list (skip dummy node)
        return dummyHead.next;
    }
}
# Time and Space Complexity
Time Complexity: O(n)

The algorithm consists of two sequential while loops:

The first loop iterates through all n nodes in the original linked list to create new nodes and build the mapping dictionary. Each operation inside this loop (creating a node, updating pointers, adding to dictionary) takes O(1) time.
The second loop iterates through all n nodes again to set the random pointers using the dictionary lookup, which is O(1) per operation.
Therefore, the total time complexity is O(n) + O(n) = O(n).

Space Complexity: O(n)

The algorithm uses additional space for:

A dictionary d that stores mappings from original nodes to copied nodes, containing n key-value pairs: O(n)
The new linked list with n nodes that are being created as the deep copy: O(n)
A few constant auxiliary variables (dummy, tail, cur, node): O(1)
The space for the output linked list is typically considered part of the space complexity for this problem, so the total space complexity is O(n).
