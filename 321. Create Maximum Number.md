ğŸ”¥ **LeetCode 321 â€“ Create Maximum Number**
This is an **ADVANCED + INTERVIEW-KILLER** problem ğŸ˜
Uses **Greedy + Monotonic Stack + Two Pointers + Merge Logic**

Iâ€™ll explain **teacher-style, Hinglish**, exactly how you should teach it on board.

---

# ğŸ§  Problem Samajh Lo (Clear First)

Tumhe do arrays diye gaye hain:

```
nums1, nums2
```

Aur ek integer `k`

ğŸ‘‰ Tumhe **k length ka maximum possible number** banana hai
ğŸ‘‰ Digits ka **relative order maintain** karna hai
ğŸ‘‰ Digits nums1 ya nums2 se aa sakte hain

---

### Example

```
nums1 = [3,4,6,5]
nums2 = [9,1,2,5,8,3]
k = 5

Output = [9,8,6,5,3]
```

---

# ğŸš¨ Why This Problem Is Hard?

Because:

* Tumhe decide karna hai:

  * nums1 se kitne digits lo?
  * nums2 se kitne digits lo?
* Fir unhe **lexicographically maximum** way me merge karna hai

---

# ğŸ§© Big Picture Strategy (MOST IMPORTANT)

Problem ko **3 parts** me todo ğŸ‘‡

---

## ğŸŸ¢ PART 1: Pick Maximum Subsequence of Length `x` (Monotonic Stack)

### ğŸ”¥ Question:

> Array se `x` digits uthao such that number maximum ho

ğŸ‘‰ Same logic as **Remove K Digits (402)** but ulta (maximize)

---

### ğŸ§  Logic

* Stack use karo
* Jab current digit bada ho & abhi pop kar sakte ho â†’ pop

---

### Code (Helper Function)

```java
private int[] maxSubsequence(int[] nums, int k) {
    int drop = nums.length - k;
    Stack<Integer> stack = new Stack<>();

    for (int num : nums) {
        while (!stack.isEmpty() && drop > 0 && stack.peek() < num) {
            stack.pop();
            drop--;
        }
        stack.push(num);
    }

    int[] res = new int[k];
    for (int i = k - 1; i >= 0; i--) {
        res[i] = stack.pop();
    }
    return res;
}
```

ğŸ“Œ Teach this separately on board

---

## ğŸŸ¢ PART 2: Merge Two Arrays into Maximum Number

### ğŸ§  Intuition

Normal merge nahi chalega
Agar equal digits ho â†’ **look ahead** karo

---

### Code (Merge Logic)

```java
private int[] merge(int[] a, int[] b) {
    int[] res = new int[a.length + b.length];
    int i = 0, j = 0, r = 0;

    while (i < a.length || j < b.length) {
        if (greater(a, i, b, j)) {
            res[r++] = i < a.length ? a[i++] : b[j++];
        } else {
            res[r++] = b[j++];
        }
    }
    return res;
}
```

---

### Lexicographical Compare Function

```java
private boolean greater(int[] a, int i, int[] b, int j) {
    while (i < a.length && j < b.length && a[i] == b[j]) {
        i++;
        j++;
    }
    if (j == b.length) return true;
    if (i < a.length && a[i] > b[j]) return true;
    return false;
}
```

---

## ğŸŸ¢ PART 3: Try All Possible Splits ğŸ”¥

nums1 se `i` digits
nums2 se `k-i` digits

---

### Main Loop

```java
class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {

        int[] best = new int[k];
        int n1 = nums1.length, n2 = nums2.length;

        for (int i = Math.max(0, k - n2); i <= Math.min(k, n1); i++) {

            int[] part1 = maxSubsequence(nums1, i);
            int[] part2 = maxSubsequence(nums2, k - i);

            int[] candidate = merge(part1, part2);

            if (greater(candidate, 0, best, 0)) {
                best = candidate;
            }
        }
        return best;
    }

    // helper methods pasted here
}
```

---

# â±ï¸ Time Complexity (Interview Important)

```
O(k * (n1 + n2))
```

Acceptable given constraints

---

# ğŸ§‘â€ğŸ« Board Teaching Flow (Highly Recommended)

### 1ï¸âƒ£ Write problem + example

### 2ï¸âƒ£ Explain why brute force impossible

### 3ï¸âƒ£ Teach:

* Max subsequence using stack
* Merge logic with look-ahead

### 4ï¸âƒ£ Combine all three steps

---

# ğŸ§  Interview One-Liner

> We try all valid splits, extract maximum subsequences using a greedy stack, and merge them lexicographically to get the maximum number.

---

# ğŸ”¥ Patterns Used (Tell Students)

âœ… Monotonic Stack
âœ… Greedy
âœ… Two pointers
âœ… Lexicographical comparison

---

# âš ï¸ Common Mistakes

âŒ Normal merge (without look-ahead)
âŒ Forgetting split boundaries
âŒ Comparing only first digit

---

# ğŸŸ¢ Related Problems (Must Do)

* 402. Remove K Digits
* 316. Remove Duplicate Letters
* 1081. Smallest Subsequence
* 321 (this ğŸ”¥)

---

If you want next:

* âœ… Visual animation explanation
* âœ… Python version
* âœ… Interview dry run
* âœ… Teaching slides format

Just say ğŸš€
