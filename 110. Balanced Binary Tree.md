```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        // If the tree is empty, we can say its balanced
        if (root == null) return true;
        // Height Function will return -1, when its an unbalanced tree
        if (Height(root) == -1) return false;
        return true;
    }


    // Create a function to return the height of a current subtree using recursion
    public int Height(TreeNode root) {
      // base case 
      if (root == null) return 0;
      // Height of the left subtree
      int leftHeight = Height(root.left);
      // height of height subtree
      int rightHight = Height(root.right);
      // in case of left subtree or right subtree unbalanced, return -1
      if (leftHeight == -1 || rightHight == -1) return -1;
      // if their height differ by more than 1 return -1
      if (Math.abs(leftHeight - rightHight) > 1) return -1;
      // otherwise, return the height of this subtree
      return Math.max(leftHeight, rightHight) + 1;
    }
}
```

Perfect question ğŸ‘Œ
Ye **Balanced Binary Tree (LeetCode 110)** ka **best & optimized solution** hai.
Chalo isko **intuition + step-by-step dry run** ke saath **Hinglish** me samajhte hain ğŸ˜„

---

## ğŸ” Problem Intuition (Balanced Binary Tree kya hota hai?)

A **binary tree balanced** hota hai agar:

ğŸ‘‰ **Har node ke liye**

```
|height(left subtree) - height(right subtree)| â‰¤ 1
```

Agar kisi **ek bhi node** par ye condition break ho jaaye â†’ **tree unbalanced âŒ**

---

## ğŸ’¡ Is code ka main idea (Smart Trick)

Normally:

* Har node par height calculate karo
* Fir balance check karo
  â›” Ye approach slow ho jaata hai (O(nÂ²))

### ğŸ”¥ Optimized Idea:

ğŸ‘‰ **Height calculate karte waqt hi balance check kar lo**

ğŸ“Œ Trick:

* Agar kahin bhi tree **unbalanced mile**, to **-1 return** kar do
* `-1` ka matlab = **"Tree yahin se unbalanced ho chuka hai"**

---

## ğŸ§  Code Breakdown (Line by Line)

### âœ… `isBalanced()` function

```java
public boolean isBalanced(TreeNode root) {
    if (root == null) return true;
    if (Height(root) == -1) return false;
    return true;
}
```

### Intuition:

* Empty tree â†’ obviously balanced âœ…
* `Height(root)` call karo

  * Agar `-1` mila â†’ âŒ unbalanced
  * Warna â†’ âœ… balanced

---

## ğŸŒ³ `Height()` function (Yahin main game hai)

```java
public int Height(TreeNode root) {
    if (root == null) return 0;
```

### Base case:

* Null node ki height = `0`

---

```java
int leftHeight = Height(root.left);
int rightHight = Height(root.right);
```

### Kya ho raha hai?

* Pehle **left subtree ki height**
* Phir **right subtree ki height**
* Recursive DFS (postorder traversal)

---

```java
if (leftHeight == -1 || rightHight == -1) return -1;
```

### Intuition:

* Agar left ya right subtree pehle hi **unbalanced mil chuka hai**
* To aage check karne ka fayda nahi
* Turant `-1` return âŒ

---

```java
if (Math.abs(leftHeight - rightHight) > 1) return -1;
```

### Balance Condition:

* Agar height difference > 1
* Matlab current node par tree **unbalanced**
* Return `-1`

---

```java
return Math.max(leftHeight, rightHight) + 1;
```

### Agar balanced hai:

* Current node ki height return karo

---

## ğŸ§ª Dry Run (Step-by-Step Example)

### Example Tree:

```
        1
       / \
      2   3
     /
    4
```

---

### Step 1ï¸âƒ£ Node 4

* left = 0
* right = 0
* diff = 0 âœ…
* height = `1`

---

### Step 2ï¸âƒ£ Node 2

* left = 1 (node 4)
* right = 0
* diff = 1 âœ…
* height = `2`

---

### Step 3ï¸âƒ£ Node 3

* left = 0
* right = 0
* height = `1`

---

### Step 4ï¸âƒ£ Node 1

* left = 2
* right = 1
* diff = 1 âœ…
* height = `3`

âœ… **Tree Balanced â†’ true**

---

## âŒ Unbalanced Tree Example

```
        1
       /
      2
     /
    3
```

### Node 3 â†’ height = 1

### Node 2 â†’ left = 1, right = 0 â†’ height = 2

### Node 1 â†’ left = 2, right = 0 â†’ diff = 2 âŒ

â¡ `Height()` returns `-1`
â¡ `isBalanced()` returns **false**

---

## ğŸš€ Why this approach is BEST?

| Feature         | Value                     |
| --------------- | ------------------------- |
| Time Complexity | **O(n)**                  |
| Space           | **O(height of tree)**     |
| Traversal       | Postorder                 |
| Trick           | Early stopping using `-1` |

---

## ğŸ§  One-Line Intuition

> **â€œHeight calculate karo, aur jaise hi imbalance mile â€” wahi se tree reject kar do.â€**

---

Agar chaho to next:

* ğŸ”¹ Recursive vs Iterative approach
* ğŸ”¹ Visual stack trace
* ğŸ”¹ Interview explanation version (30 sec answer)
* ğŸ”¹ DFS / Postorder visualization

Bas bol do ğŸ˜„ğŸ’ª
