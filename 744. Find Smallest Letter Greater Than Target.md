Nice choice ğŸ‘ This is a **classic binary search** problem from LeetCode and very important for interviews.

---

## ğŸ”¹ Problem 744: Find Smallest Letter Greater Than Target

### ğŸ“Œ Problem Statement

You are given a **sorted array of characters** `letters` (in non-decreasing order) and a character `target`.

ğŸ‘‰ **Return the smallest character in the array that is strictly greater than `target`.**

âš ï¸ **Important twist:**
The array is **circular** â€” if no character is greater than `target`, return the **first character** of the array.

---

## ğŸ”¹ Example

### Example 1

```
Input: letters = ['c','f','j'], target = 'a'
Output: 'c'
```

### Example 2

```
Input: letters = ['c','f','j'], target = 'c'
Output: 'f'
```

### Example 3 (wrap-around case)

```
Input: letters = ['c','f','j'], target = 'j'
Output: 'c'
```

---

## ğŸ”¹ Key Observations ğŸ’¡

1. The array is **sorted** â†’ use **Binary Search**
2. We are NOT looking for `target`
3. We want the **first character > target**
4. If `target` â‰¥ all characters â†’ return `letters[0]` (wrap around)

---

## ğŸ”¹ Approach 1: Binary Search (Optimal)

### ğŸ§  Idea

* Perform binary search
* If `letters[mid] <= target`, move right
* Else, store answer and move left
* Finally:

  * If index goes out of range â†’ return `letters[0]`

---

## ğŸ”¹ Java Code (Recommended Solution)

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int start = 0;
        int end = letters.length - 1;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (letters[mid] <= target) {
                // move right if mid is less than or equal to target
                start = mid + 1;
            } else {
                // possible answer, move left to find smaller greater
                end = mid - 1;
            }
        }

        // start can go out of bounds, so use modulo
        return letters[start % letters.length];
    }
}
```

---

## ğŸ”¹ Step-by-Step Dry Run ğŸ”

### Input

```
letters = ['c','f','j']
target = 'j'
```

| start | end | mid | letters[mid] | Action                |
| ----- | --- | --- | ------------ | --------------------- |
| 0     | 2   | 1   | 'f'          | 'f' â‰¤ 'j' â†’ start = 2 |
| 2     | 2   | 2   | 'j'          | 'j' â‰¤ 'j' â†’ start = 3 |

Now:

```
start = 3
letters.length = 3
start % length = 0
Answer = 'c'
```

âœ” Correct!

---

## ğŸ”¹ Why `start % letters.length`? ğŸ¤”

* If no greater character exists:

  ```
  start == letters.length
  ```
* Modulo wraps it back:

  ```
  letters[start % letters.length] = letters[0]
  ```

This handles the **circular condition** cleanly.

---

## ğŸ”¹ Time & Space Complexity ğŸ“Š

* **Time:** `O(log n)`
* **Space:** `O(1)`

---

## ğŸ”¹ Interview Tips ğŸ’¬

âœ” Mention **binary search**
âœ” Mention **circular array logic**
âœ” Explain why modulo is used
âœ” Avoid linear scan (O(n)) unless asked

---

If you want:

* â“ **Alternate brute-force solution**
* ğŸ§ª **More dry runs**
* ğŸ” **Similar problems list**
* ğŸ“˜ **Binary search pattern notes**

Just tell me ğŸ˜„
